#!/usr/bin/env python
# -*- coding: ISO8859-1 -*-
#
# Copyright 2004 Norwegian University of Science and Technology
# Copyright 2006 UNINETT AS
#
# This file is part of Network Administration Visualized (NAV)
#
# NAV is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# NAV is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with NAV; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
#
# This is the Common start/stop script for all NAV services.  It will
# also manage loading/unloading of cron-based tasks in the NAV system.
#
# Authors: Morten Brekkevold <morten.brekkevold@uninett.no>
#
"""This command is your interface to start, stop and query NAV services.

Usage: nav [command] [service ...]

The selected command will be applied to all known services, unless you
specify a list of services after the command.
Available commands are:

  start   -- Start services.
  stop    -- Stop services.
  status  -- Query the status of services.
  info    -- Display information about/description of services.
  list    -- Display list of known services.
  
  version -- Displays which version of NAV you are running.
"""
__id__ = "$Id$"

import sys
import os
import os.path
import getopt
try:
    from startstop import *
except ImportError:
    try:
        from nav.startstop import *
    except ImportError:
        print >> sys.stderr, """Fatal error: Could not find the nav.startstop module.
Is your PYTHONPATH environment correctly set up?"""
        sys.exit(1)

try:
    services = ServiceRegistry()
except OSError, e:
    print >> sys.stderr, "A problem occurred, which prevented this command from running."
    print >> sys.stderr, str(e)
    sys.exit(1)

allowNonRoot = False

def main(args):
    global services
    
    try:
        opts, args = getopt.getopt(args, '', ['nonroot'])
    except getopt.GetoptError, error:
        print >> sys.stderr, error
        usage()
        sys.exit(1)

    for opt,val in opts:
        if opt == '--nonroot':
            global allowNonRoot
            allowNonRoot = True

    if len(args) == 0:
        usage()
        sys.exit(1)

    command = args.pop(0)
    if len(args) == 0:
        queryList = services.keys()
        queryList.sort()
    else:
        queryList = args

    # Use reflection to decide whether the command is known, and to
    # call it if it is.
    self = sys.modules[__name__]
    commandFuncName = 'c_' + command
    if hasattr(self, commandFuncName):
        commandFunc = self.__dict__[commandFuncName]
        commandFunc(queryList)
    else:
        print >> sys.stderr, "Unknown command: " + command

def checkroot():
    if not allowNonRoot and os.geteuid() != 0:
        print >> sys.stderr, "You should be root to run this command."
        sys.exit(10)

def serviceIterator(queryList, func):
    """Iterate through a list of service names, look up each service instance
    and call func using this instance as its argument.
    """
    unknowns = []
    for name in queryList:
        if name in services:
            func(services[name])
        else:
            unknowns.append(name)
    if len(unknowns):
        sys.stderr.write("Unknown services: %s\n" % " ".join(unknowns))

def actionIterator(queryList, action, okString, failString):
    """Iterate through a list of service names, performing an action on each
    of them.
    """
    failed = []
    unknowns = []
    errors = []

    anyOk = False
    for name in queryList:
        if name in services:
            method = eval('services[name].%s' % action)
            try:
                if method(silent=True):
                    if not anyOk:
                        anyOk = True
                        print okString + ":",
                    print name,
                    sys.stdout.flush()
                else:
                    failed.append(name)
            except CommandFailedError, error:
                errors.append((name, error))
        else:
            unknowns.append(name)
    if anyOk:
        print
    
    if len(failed):
        print "%s: %s" % (failString, " ".join(failed))
    if len(unknowns):
        print "Unknown: %s" % " ".join(unknowns)
    if len(errors):
        print "Errors:",
        print " ".join(["%s (%s)" % error for error in errors])

def c_info(queryList):
    def helper(service):
        print "%s (%s): %s" % (service.name,
                               service.__class__.__name__,
                               service.info)
    serviceIterator(queryList, helper)
    
def c_list(queryList):
    def helper(service):
        print service.name
    serviceIterator(queryList, helper)

def c_start(queryList):
    checkroot()
    actionIterator(queryList, "start", "Starting", "Failed")
        
def c_stop(queryList):
    checkroot()
    actionIterator(queryList, "stop", "Stopping", "Failed")

def c_restart(queryList):
    checkroot()
    c_stop(queryList)
    c_start(queryList)
        
def c_status(queryList):
    checkroot()
    actionIterator(queryList, "isUp", "Up", "Down")

def c_version(queryList):
    import nav
    if hasattr(nav, '__version__'):
        print "NAV " + nav.__version__
    elif hasattr(nav, 'VERSION'):
        print "NAV " + nav.VERSION
    else:
        print >> sys.stderr, "I cannot find any NAV version information!"

def usage():
    """ Print a usage screen to stderr."""
    print >> sys.stderr, __doc__

##############
# begin here #
##############
if __name__ == '__main__':
    main(sys.argv[1:])
